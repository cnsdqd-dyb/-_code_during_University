作业二 

### 一、写出下面程序的运行结果

#### 1

```
Hello!I love JA V A.
```

#### 2

```
s=180
```

#### 3

```
a=22
b=22
```

#### 4

```
10
```

调用语句为：this(a);

#### 5

```
a
b
c
d
```

#### 6

```
0
```

### 二、程序设计题

```java
package base_dongyubo;

public class HelloWorld {
	public static void main(String args [ ]) {
		ComplexNumber A = new ComplexNumber();
		ComplexNumber B = new ComplexNumber();
		ComplexNumber C = new ComplexNumber();
		ComplexNumber D = new ComplexNumber();
		ComplexNumber E = new ComplexNumber();
		
		System.out.println(A.setValue(0,0));
		System.out.println(A.setValue(0,2));
		System.out.println(A.setValue(1,0));
		System.out.println(A.setValue(1,2));
		
		System.out.println(A.setValue(1,2)+"+"+B.setValue(2,2)+"="+C.add(A,B));//仿照tensorflow~
		System.out.println(A.setValue(1,2)+"-"+B.setValue(2,2)+"="+A.sub(B));//两种写法
		System.out.println(A.setValue(1,2)+"*"+B.setValue(2,2)+"="+A.multiply(B));
		System.out.println(A.setValue(1,2)+"*"+B.setValue(2,2)+"="+C.multiply(A,B));
		System.out.println(C.setValue(1,2)+"/"+D.setValue(2,2)+"="+E.div(A,B));
		System.out.println(D+"*"+E+"="+C.multiply(D,E));
		System.out.println(D.setValue(1,2)+"^2="+D.pow2());
		System.out.println(E.setValue(1,2)+"的共轭="+A.conjugate());
	}

	void sayHello() {
		System.out.println("HelloWorld");
	}
}

class ComplexNumber{
	double RealNumber;
	double ImagineNumber;
	ComplexNumber(){
		this(0.0, 0.0);
	}
	ComplexNumber(double real,double imagine){
		this.RealNumber = real;
		this.ImagineNumber = imagine;
	}
	public ComplexNumber setValue(double real,double imagine){
		this.RealNumber = real;
		this.ImagineNumber = imagine;
		return this;
	}
	public ComplexNumber add(ComplexNumber A,ComplexNumber B) {
		try {
			this.RealNumber = A.RealNumber + B.RealNumber;
			this.ImagineNumber = A.ImagineNumber + B.ImagineNumber;
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		return this;
	}
	public ComplexNumber add(ComplexNumber A) {
		ComplexNumber C = new ComplexNumber();
		try {
			C.RealNumber = A.RealNumber + this.RealNumber;
			C.ImagineNumber = A.ImagineNumber + this.ImagineNumber;
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		return C;
	}
	public ComplexNumber sub(ComplexNumber B,ComplexNumber A) {
		try {
			this.RealNumber = B.RealNumber - A.RealNumber;
			this.ImagineNumber = B.ImagineNumber - A.ImagineNumber;
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		return this;
	}
	public ComplexNumber sub(ComplexNumber A) {
		ComplexNumber C = new ComplexNumber();
		try {
			C.RealNumber = this.RealNumber - A.RealNumber;
			C.ImagineNumber = this.ImagineNumber - A.ImagineNumber;
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		return C;
	}
	public ComplexNumber multiply(ComplexNumber A,ComplexNumber B) {
		try {
			this.RealNumber = A.RealNumber * B.RealNumber - A.ImagineNumber * B.ImagineNumber;
			this.ImagineNumber = A.RealNumber * B.ImagineNumber + A.ImagineNumber * B.RealNumber;
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		return this;
	}
	public ComplexNumber multiply(ComplexNumber A) {
		ComplexNumber C = new ComplexNumber();
		try {
			C.RealNumber = A.RealNumber * this.RealNumber - A.ImagineNumber * this.ImagineNumber;
			C.ImagineNumber = A.RealNumber * this.ImagineNumber + A.ImagineNumber * this.RealNumber;
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		return C;
	}
	public ComplexNumber div(ComplexNumber B,ComplexNumber A) {
		try {
			double under = A.RealNumber*A.RealNumber + A.ImagineNumber*A.ImagineNumber;
			this.RealNumber = (B.RealNumber * A.RealNumber + B.ImagineNumber * A.ImagineNumber)/under;
			this.ImagineNumber = (-B.RealNumber * A.ImagineNumber + B.ImagineNumber * A.RealNumber)/under;
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		return this;
	}
	public ComplexNumber div(ComplexNumber A) {
		ComplexNumber C = new ComplexNumber();
		try {
			double under = A.RealNumber*A.RealNumber + A.ImagineNumber*A.ImagineNumber;
			C.RealNumber = (this.RealNumber * A.RealNumber + this.ImagineNumber * A.ImagineNumber)/under;
			C.ImagineNumber = (-this.RealNumber * A.ImagineNumber + this.ImagineNumber * A.RealNumber)/under;
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		return C;
	}
	/*
	 *  @brief 平方
	 */
	public ComplexNumber pow2() {
		ComplexNumber C = new ComplexNumber();
		try {
			C = this.multiply(this);
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		this.ImagineNumber = C.ImagineNumber;
		this.RealNumber = C.RealNumber;
		return this;
	}
	public ComplexNumber pow2(ComplexNumber A) {
		ComplexNumber C = new ComplexNumber();
		try {
			C = this.multiply(A);
		}
		catch(ArithmeticException e){
			e.printStackTrace();
		}
		return C;
	}
	public ComplexNumber conjugate() {
		this.ImagineNumber = -this.ImagineNumber;
		return this;
	}
	public ComplexNumber conjugate(ComplexNumber A) {
		ComplexNumber C = new ComplexNumber();
		C.ImagineNumber = -A.ImagineNumber;
		C.RealNumber = A.RealNumber;
		return C;
	}
	public String toString() {
		if(this.ImagineNumber==0)
			return this.RealNumber+"";
		else if(this.RealNumber==0)
			return this.ImagineNumber+"i";
		else
			return "("+this.RealNumber+","+this.ImagineNumber+"i"+")";
	}
}

```

### 三、问答题

1. `static`表示静态变量 ，在初始化的时候，即使没有实例成员，也可以访问静态变量和静态方法。

   静态方法不能被`override`动态复写，`private`方法默认具有final属性，也不能被复写。